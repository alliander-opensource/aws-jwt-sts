"use strict";
// SPDX-FileCopyrightText: 2023 Alliander NV
//
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_kms_1 = require("@aws-sdk/client-kms");
const client_s3_1 = require("@aws-sdk/client-s3");
const jsrsasign_1 = require("jsrsasign");
const client = new client_kms_1.KMSClient({});
const ALIAS_PREVIOUS = process.env.PREVIOUS_KEY.toString();
const ALIAS_CURRENT = process.env.CURRENT_KEY.toString();
const ALIAS_PENDING = process.env.PENDING_KEY.toString();
const ALIASES = [
    ALIAS_PREVIOUS,
    ALIAS_CURRENT,
    ALIAS_PENDING
];
const handler = async (event) => {
    // retrieve the step from the event
    const step = (event.step);
    // match the step with the corresponding function
    switch (step) {
        case 'deletePrevious':
            await deletePrevious();
            break;
        case 'movePrevious':
            await movePrevious();
            break;
        case 'moveCurrent':
            await moveCurrent();
            break;
        case 'createPending':
            await createPending();
            break;
        case 'generateArtifacts':
            await generateJWKS();
            await generateOpenIDConfiguration();
            break;
        default:
            console.log('invalid step');
    }
};
exports.handler = handler;
async function deletePrevious() {
    console.log('Deleting PREVIOUS aliased key');
    const prevKeyId = await getKeyIdForAlias(ALIAS_PREVIOUS);
    if (prevKeyId) {
        const ScheduleDeleteResponse = await client.send(new client_kms_1.ScheduleKeyDeletionCommand({ KeyId: prevKeyId }));
        console.log(ScheduleDeleteResponse);
    }
    else {
        console.log('No PREVIOUS key at the moment, skip deletion');
    }
}
async function movePrevious() {
    console.log('moving PREVIOUS alias');
    const currentKeyId = await getKeyIdForAlias(ALIAS_CURRENT);
    if (currentKeyId) {
        await updateOrCreateAlias(ALIAS_PREVIOUS, currentKeyId);
    }
    else {
        console.log('No CURRENT key at the moment, skip assigning the PREVIOUS alias to this key.');
    }
}
async function moveCurrent() {
    console.log('Moving CURRENT alias');
    const pendingKeyId = await getKeyIdForAlias(ALIAS_PENDING);
    if (pendingKeyId) {
        await updateOrCreateAlias(ALIAS_CURRENT, pendingKeyId);
    }
    else {
        console.log('No PENDING key at the moment, skip assigning the CURRENT alias to this key.');
    }
}
async function createPending() {
    console.log('Creating new key for PENDING');
    // Create new key
    const createResponse = await client.send(new client_kms_1.CreateKeyCommand({
        KeySpec: 'RSA_2048',
        KeyUsage: 'SIGN_VERIFY'
    }));
    console.log(createResponse);
    // Update the new key with pending alias
    await updateOrCreateAlias(ALIAS_PENDING, createResponse.KeyMetadata.KeyId);
}
async function updateOrCreateAlias(aliasName, keyId) {
    try {
        const updateResponse = await client.send(new client_kms_1.UpdateAliasCommand({
            AliasName: aliasName,
            TargetKeyId: keyId
        }));
        console.log(updateResponse);
    }
    catch (err) {
        if (err instanceof client_kms_1.NotFoundException) {
            console.log('ALIAS not found, creating it.');
            const createResponse = await client.send(new client_kms_1.CreateAliasCommand({
                AliasName: aliasName,
                TargetKeyId: keyId
            }));
            console.log(createResponse);
        }
        else {
            throw (err);
        }
    }
}
async function getKeyIdForAlias(keyId) {
    var _a;
    try {
        const response = await client.send(new client_kms_1.DescribeKeyCommand({ KeyId: keyId }));
        console.log(response);
        return (_a = response.KeyMetadata) === null || _a === void 0 ? void 0 : _a.KeyId;
    }
    catch (err) {
        if (err instanceof client_kms_1.NotFoundException) {
            return null;
        }
        else {
            throw err;
        }
    }
}
async function generateJWKS() {
    const allKeys = [];
    for (const keyAlias of ALIASES) {
        const keyId = await getKeyIdForAlias(keyAlias);
        if (keyId) {
            const jwkContents = await generateJWK(keyAlias);
            await setKMSKeyTags(keyId, [{ TagKey: 'jwk_kid', TagValue: jwkContents.kid }]);
            allKeys.push(jwkContents);
        }
    }
    const result = { keys: allKeys };
    await uploadToS3('discovery/keys', result);
}
async function generateOpenIDConfiguration() {
    const issuer = process.env.ISSUER;
    const openIdConfiguration = {
        issuer,
        jwks_uri: `${issuer}/discovery/keys`,
        response_types_supported: [
            'token'
        ],
        id_token_signing_alg_values_supported: [
            'RS256'
        ],
        scopes_supported: [
            'openid'
        ],
        token_endpoint_auth_methods_supported: [
            'client_secret_basic'
        ],
        claims_supported: [
            'aud',
            'exp',
            'iat',
            'iss',
            'sub'
        ]
    };
    await uploadToS3('.well-known/openid-configuration', openIdConfiguration);
}
async function generateJWK(keyAlias) {
    // Get the public key from kms
    const getPubKeyResponse = await client.send(new client_kms_1.GetPublicKeyCommand({ KeyId: keyAlias }));
    // generate HEX format from the response (DER)
    const pubKeyHex = Buffer.from(getPubKeyResponse.PublicKey).toString('hex');
    // Get the pub key in pem format
    const pubKeyPem = jsrsasign_1.KJUR.asn1.ASN1Util.getPEMStringFromHex(pubKeyHex, 'PUBLIC KEY');
    // return the JWK format for the key
    const jwk = jsrsasign_1.KEYUTIL.getJWK(pubKeyPem);
    jwk.use = 'sig';
    jwk.alg = 'RS256';
    return jwk;
}
async function setKMSKeyTags(keyAlias, tags) {
    return await client.send(new client_kms_1.TagResourceCommand({ KeyId: keyAlias, Tags: tags }));
}
async function uploadToS3(key, contents) {
    // get S3 bucket from environment variables
    const s3Bucket = process.env.S3_BUCKET;
    const s3client = new client_s3_1.S3Client({});
    // Write jwk to s3 bucket
    await s3client.send(new client_s3_1.PutObjectCommand({
        Bucket: s3Bucket,
        Key: key, // File name you want to save as in S3
        Body: Buffer.from(JSON.stringify(contents)),
        ContentType: 'application/json',
        ContentEncoding: ''
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgua2V5cm90YXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2luZGV4LmtleXJvdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsNENBQTRDO0FBQzVDLEVBQUU7QUFDRixzQ0FBc0M7OztBQUV0QyxvREFXNEI7QUFDNUIsa0RBQStEO0FBQy9ELHlDQUF5QztBQUV6QyxNQUFNLE1BQU0sR0FBRyxJQUFJLHNCQUFTLENBQUMsRUFBRSxDQUFDLENBQUE7QUFFaEMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFhLENBQUMsUUFBUSxFQUFFLENBQUE7QUFDM0QsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFZLENBQUMsUUFBUSxFQUFFLENBQUE7QUFDekQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFZLENBQUMsUUFBUSxFQUFFLENBQUE7QUFFekQsTUFBTSxPQUFPLEdBQWE7SUFDeEIsY0FBYztJQUNkLGFBQWE7SUFDYixhQUFhO0NBQ2QsQ0FBQTtBQUVNLE1BQU0sT0FBTyxHQUFHLEtBQUssRUFBRSxLQUFVLEVBQWdCLEVBQUU7SUFDeEQsbUNBQW1DO0lBQ25DLE1BQU0sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFBO0lBRXpCLGlEQUFpRDtJQUNqRCxRQUFRLElBQUksRUFBRSxDQUFDO1FBQ2IsS0FBSyxnQkFBZ0I7WUFDbkIsTUFBTSxjQUFjLEVBQUUsQ0FBQTtZQUN0QixNQUFLO1FBQ1AsS0FBSyxjQUFjO1lBQ2pCLE1BQU0sWUFBWSxFQUFFLENBQUE7WUFDcEIsTUFBSztRQUNQLEtBQUssYUFBYTtZQUNoQixNQUFNLFdBQVcsRUFBRSxDQUFBO1lBQ25CLE1BQUs7UUFDUCxLQUFLLGVBQWU7WUFDbEIsTUFBTSxhQUFhLEVBQUUsQ0FBQTtZQUNyQixNQUFLO1FBQ1AsS0FBSyxtQkFBbUI7WUFDdEIsTUFBTSxZQUFZ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QUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUE7SUFFakYsb0NBQW9DO0lBQ3BDLE1BQU0sR0FBRyxHQUFRLG1CQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBRTFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFBO0lBQ2YsR0FBRyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUE7SUFFakIsT0FBTyxHQUFHLENBQUE7QUFDWixDQUFDO0FBRUQsS0FBSyxVQUFVLGFBQWEsQ0FBRSxRQUFnQixFQUFFLElBQVc7SUFDekQsT0FBTyxNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSwrQkFBa0IsQ0FBQyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUNuRixDQUFDO0FBRUQsS0FBSyxVQUFVLFVBQVUsQ0FBRSxHQUFXLEVBQUUsUUFBZ0I7SUFDdEQsMkNBQTJDO0lBQzNDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFBO0lBRXRDLE1BQU0sUUFBUSxHQUFHLElBQUksb0JBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQTtJQUVqQyx5QkFBeUI7SUFDekIsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksNEJBQWdCLENBQUM7UUFDdkMsTUFBTSxFQUFFLFFBQVE7UUFDaEIsR0FBRyxFQUFFLEdBQUcsRUFBRSxzQ0FBc0M7UUFDaEQsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQyxXQUFXLEVBQUUsa0JBQWtCO1FBQy9CLGVBQWUsRUFBRSxFQUFFO0tBQ3BCLENBQUMsQ0FBQyxDQUFBO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IDIwMjMgQWxsaWFuZGVyIE5WXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuaW1wb3J0IHtcbiAgS01TQ2xpZW50LFxuICBEZXNjcmliZUtleUNvbW1hbmQsXG4gIEdldFB1YmxpY0tleUNvbW1hbmQsXG4gIENyZWF0ZUtleUNvbW1hbmQsXG4gIFVwZGF0ZUFsaWFzQ29tbWFuZCxcbiAgU2NoZWR1bGVLZXlEZWxldGlvbkNvbW1hbmQsXG4gIFRhZ1Jlc291cmNlQ29tbWFuZCxcbiAgVGFnLFxuICBOb3RGb3VuZEV4Y2VwdGlvbixcbiAgQ3JlYXRlQWxpYXNDb21tYW5kXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1rbXMnXG5pbXBvcnQgeyBTM0NsaWVudCwgUHV0T2JqZWN0Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1zMydcbmltcG9ydCB7IEtFWVVUSUwsIEtKVVIgfSBmcm9tICdqc3JzYXNpZ24nXG5cbmNvbnN0IGNsaWVudCA9IG5ldyBLTVNDbGllbnQoe30pXG5cbmNvbnN0IEFMSUFTX1BSRVZJT1VTID0gcHJvY2Vzcy5lbnYuUFJFVklPVVNfS0VZIS50b1N0cmluZygpXG5jb25zdCBBTElBU19DVVJSRU5UID0gcHJvY2Vzcy5lbnYuQ1VSUkVOVF9LRVkhLnRvU3RyaW5nKClcbmNvbnN0IEFMSUFTX1BFTkRJTkcgPSBwcm9jZXNzLmVudi5QRU5ESU5HX0tFWSEudG9TdHJpbmcoKVxuXG5jb25zdCBBTElBU0VTOiBzdHJpbmdbXSA9IFtcbiAgQUxJQVNfUFJFVklPVVMsXG4gIEFMSUFTX0NVUlJFTlQsXG4gIEFMSUFTX1BFTkRJTkdcbl1cblxuZXhwb3J0IGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZXZlbnQ6IGFueSk6IFByb21pc2U8YW55PiA9PiB7XG4gIC8vIHJldHJpZXZlIHRoZSBzdGVwIGZyb20gdGhlIGV2ZW50XG4gIGNvbnN0IHN0ZXAgPSAoZXZlbnQuc3RlcClcblxuICAvLyBtYXRjaCB0aGUgc3RlcCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uXG4gIHN3aXRjaCAoc3RlcCkge1xuICAgIGNhc2UgJ2RlbGV0ZVByZXZpb3VzJzpcbiAgICAgIGF3YWl0IGRlbGV0ZVByZXZpb3VzKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbW92ZVByZXZpb3VzJzpcbiAgICAgIGF3YWl0IG1vdmVQcmV2aW91cygpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ21vdmVDdXJyZW50JzpcbiAgICAgIGF3YWl0IG1vdmVDdXJyZW50KClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnY3JlYXRlUGVuZGluZyc6XG4gICAgICBhd2FpdCBjcmVhdGVQZW5kaW5nKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZ2VuZXJhdGVBcnRpZmFjdHMnOlxuICAgICAgYXdhaXQgZ2VuZXJhdGVKV0tTKClcbiAgICAgIGF3YWl0IGdlbmVyYXRlT3BlbklEQ29uZmlndXJhdGlvbigpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUubG9nKCdpbnZhbGlkIHN0ZXAnKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVByZXZpb3VzICgpIHtcbiAgY29uc29sZS5sb2coJ0RlbGV0aW5nIFBSRVZJT1VTIGFsaWFzZWQga2V5JylcblxuICBjb25zdCBwcmV2S2V5SWQgPSBhd2FpdCBnZXRLZXlJZEZvckFsaWFzKEFMSUFTX1BSRVZJT1VTKVxuICBpZiAocHJldktleUlkKSB7XG4gICAgY29uc3QgU2NoZWR1bGVEZWxldGVSZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kKFxuICAgICAgbmV3IFNjaGVkdWxlS2V5RGVsZXRpb25Db21tYW5kKHsgS2V5SWQ6IHByZXZLZXlJZCB9KVxuICAgIClcbiAgICBjb25zb2xlLmxvZyhTY2hlZHVsZURlbGV0ZVJlc3BvbnNlKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdObyBQUkVWSU9VUyBrZXkgYXQgdGhlIG1vbWVudCwgc2tpcCBkZWxldGlvbicpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW92ZVByZXZpb3VzICgpIHtcbiAgY29uc29sZS5sb2coJ21vdmluZyBQUkVWSU9VUyBhbGlhcycpXG4gIGNvbnN0IGN1cnJlbnRLZXlJZCA9IGF3YWl0IGdldEtleUlkRm9yQWxpYXMoQUxJQVNfQ1VSUkVOVClcbiAgaWYgKGN1cnJlbnRLZXlJZCkge1xuICAgIGF3YWl0IHVwZGF0ZU9yQ3JlYXRlQWxpYXMoQUxJQVNfUFJFVklPVVMsIGN1cnJlbnRLZXlJZClcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnTm8gQ1VSUkVOVCBrZXkgYXQgdGhlIG1vbWVudCwgc2tpcCBhc3NpZ25pbmcgdGhlIFBSRVZJT1VTIGFsaWFzIHRvIHRoaXMga2V5LicpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbW92ZUN1cnJlbnQgKCkge1xuICBjb25zb2xlLmxvZygnTW92aW5nIENVUlJFTlQgYWxpYXMnKVxuXG4gIGNvbnN0IHBlbmRpbmdLZXlJZCA9IGF3YWl0IGdldEtleUlkRm9yQWxpYXMoQUxJQVNfUEVORElORylcbiAgaWYgKHBlbmRpbmdLZXlJZCkge1xuICAgIGF3YWl0IHVwZGF0ZU9yQ3JlYXRlQWxpYXMoQUxJQVNfQ1VSUkVOVCwgcGVuZGluZ0tleUlkKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdObyBQRU5ESU5HIGtleSBhdCB0aGUgbW9tZW50LCBza2lwIGFzc2lnbmluZyB0aGUgQ1VSUkVOVCBhbGlhcyB0byB0aGlzIGtleS4nKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmcgKCkge1xuICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGtleSBmb3IgUEVORElORycpXG5cbiAgLy8gQ3JlYXRlIG5ldyBrZXlcbiAgY29uc3QgY3JlYXRlUmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuc2VuZChuZXcgQ3JlYXRlS2V5Q29tbWFuZCh7XG4gICAgS2V5U3BlYzogJ1JTQV8yMDQ4JyxcbiAgICBLZXlVc2FnZTogJ1NJR05fVkVSSUZZJ1xuICB9KSlcbiAgY29uc29sZS5sb2coY3JlYXRlUmVzcG9uc2UpXG5cbiAgLy8gVXBkYXRlIHRoZSBuZXcga2V5IHdpdGggcGVuZGluZyBhbGlhc1xuICBhd2FpdCB1cGRhdGVPckNyZWF0ZUFsaWFzKEFMSUFTX1BFTkRJTkcsIGNyZWF0ZVJlc3BvbnNlLktleU1ldGFkYXRhIS5LZXlJZCEpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU9yQ3JlYXRlQWxpYXMgKGFsaWFzTmFtZTogc3RyaW5nLCBrZXlJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXBkYXRlUmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuc2VuZChuZXcgVXBkYXRlQWxpYXNDb21tYW5kKHtcbiAgICAgIEFsaWFzTmFtZTogYWxpYXNOYW1lLFxuICAgICAgVGFyZ2V0S2V5SWQ6IGtleUlkXG4gICAgfSkpXG4gICAgY29uc29sZS5sb2codXBkYXRlUmVzcG9uc2UpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikge1xuICAgICAgY29uc29sZS5sb2coJ0FMSUFTIG5vdCBmb3VuZCwgY3JlYXRpbmcgaXQuJylcbiAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmQobmV3IENyZWF0ZUFsaWFzQ29tbWFuZCh7XG4gICAgICAgIEFsaWFzTmFtZTogYWxpYXNOYW1lLFxuICAgICAgICBUYXJnZXRLZXlJZDoga2V5SWRcbiAgICAgIH0pKVxuICAgICAgY29uc29sZS5sb2coY3JlYXRlUmVzcG9uc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IChlcnIpXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEtleUlkRm9yQWxpYXMgKGtleUlkOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kKG5ldyBEZXNjcmliZUtleUNvbW1hbmQoeyBLZXlJZDoga2V5SWQgfSkpXG4gICAgY29uc29sZS5sb2cocmVzcG9uc2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlLktleU1ldGFkYXRhPy5LZXlJZFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUpXS1MgKCkge1xuICBjb25zdCBhbGxLZXlzOiBvYmplY3RbXSA9IFtdXG5cbiAgZm9yIChjb25zdCBrZXlBbGlhcyBvZiBBTElBU0VTKSB7XG4gICAgY29uc3Qga2V5SWQgPSBhd2FpdCBnZXRLZXlJZEZvckFsaWFzKGtleUFsaWFzKVxuICAgIGlmIChrZXlJZCkge1xuICAgICAgY29uc3QgandrQ29udGVudHMgPSBhd2FpdCBnZW5lcmF0ZUpXSyhrZXlBbGlhcylcbiAgICAgIGF3YWl0IHNldEtNU0tleVRhZ3Moa2V5SWQsIFt7IFRhZ0tleTogJ2p3a19raWQnLCBUYWdWYWx1ZTogandrQ29udGVudHMua2lkIH1dKVxuICAgICAgYWxsS2V5cy5wdXNoKGp3a0NvbnRlbnRzKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHsga2V5czogYWxsS2V5cyB9XG5cbiAgYXdhaXQgdXBsb2FkVG9TMygnZGlzY292ZXJ5L2tleXMnLCByZXN1bHQpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT3BlbklEQ29uZmlndXJhdGlvbiAoKSB7XG4gIGNvbnN0IGlzc3VlciA9IHByb2Nlc3MuZW52LklTU1VFUlxuXG4gIGNvbnN0IG9wZW5JZENvbmZpZ3VyYXRpb24gPSB7XG4gICAgaXNzdWVyLFxuICAgIGp3a3NfdXJpOiBgJHtpc3N1ZXJ9L2Rpc2NvdmVyeS9rZXlzYCxcbiAgICByZXNwb25zZV90eXBlc19zdXBwb3J0ZWQ6IFtcbiAgICAgICd0b2tlbidcbiAgICBdLFxuICAgIGlkX3Rva2VuX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQ6IFtcbiAgICAgICdSUzI1NidcbiAgICBdLFxuICAgIHNjb3Blc19zdXBwb3J0ZWQ6IFtcbiAgICAgICdvcGVuaWQnXG4gICAgXSxcbiAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkOiBbXG4gICAgICAnY2xpZW50X3NlY3JldF9iYXNpYydcbiAgICBdLFxuICAgIGNsYWltc19zdXBwb3J0ZWQ6IFtcbiAgICAgICdhdWQnLFxuICAgICAgJ2V4cCcsXG4gICAgICAnaWF0JyxcbiAgICAgICdpc3MnLFxuICAgICAgJ3N1YidcbiAgICBdXG4gIH1cblxuICBhd2FpdCB1cGxvYWRUb1MzKCcud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbicsIG9wZW5JZENvbmZpZ3VyYXRpb24pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSldLIChrZXlBbGlhczogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gR2V0IHRoZSBwdWJsaWMga2V5IGZyb20ga21zXG4gIGNvbnN0IGdldFB1YktleVJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmQobmV3IEdldFB1YmxpY0tleUNvbW1hbmQoeyBLZXlJZDoga2V5QWxpYXMgfSkpXG5cbiAgLy8gZ2VuZXJhdGUgSEVYIGZvcm1hdCBmcm9tIHRoZSByZXNwb25zZSAoREVSKVxuICBjb25zdCBwdWJLZXlIZXggPSBCdWZmZXIuZnJvbShnZXRQdWJLZXlSZXNwb25zZS5QdWJsaWNLZXkgYXMgVWludDhBcnJheSkudG9TdHJpbmcoJ2hleCcpXG5cbiAgLy8gR2V0IHRoZSBwdWIga2V5IGluIHBlbSBmb3JtYXRcbiAgY29uc3QgcHViS2V5UGVtID0gS0pVUi5hc24xLkFTTjFVdGlsLmdldFBFTVN0cmluZ0Zyb21IZXgocHViS2V5SGV4LCAnUFVCTElDIEtFWScpXG5cbiAgLy8gcmV0dXJuIHRoZSBKV0sgZm9ybWF0IGZvciB0aGUga2V5XG4gIGNvbnN0IGp3azogYW55ID0gS0VZVVRJTC5nZXRKV0socHViS2V5UGVtKVxuXG4gIGp3ay51c2UgPSAnc2lnJ1xuICBqd2suYWxnID0gJ1JTMjU2J1xuXG4gIHJldHVybiBqd2tcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0S01TS2V5VGFncyAoa2V5QWxpYXM6IHN0cmluZywgdGFnczogVGFnW10pIHtcbiAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZW5kKG5ldyBUYWdSZXNvdXJjZUNvbW1hbmQoeyBLZXlJZDoga2V5QWxpYXMsIFRhZ3M6IHRhZ3MgfSkpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFRvUzMgKGtleTogc3RyaW5nLCBjb250ZW50czogb2JqZWN0KSB7XG4gIC8vIGdldCBTMyBidWNrZXQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgY29uc3QgczNCdWNrZXQgPSBwcm9jZXNzLmVudi5TM19CVUNLRVRcblxuICBjb25zdCBzM2NsaWVudCA9IG5ldyBTM0NsaWVudCh7fSlcblxuICAvLyBXcml0ZSBqd2sgdG8gczMgYnVja2V0XG4gIGF3YWl0IHMzY2xpZW50LnNlbmQobmV3IFB1dE9iamVjdENvbW1hbmQoe1xuICAgIEJ1Y2tldDogczNCdWNrZXQsXG4gICAgS2V5OiBrZXksIC8vIEZpbGUgbmFtZSB5b3Ugd2FudCB0byBzYXZlIGFzIGluIFMzXG4gICAgQm9keTogQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoY29udGVudHMpKSxcbiAgICBDb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIENvbnRlbnRFbmNvZGluZzogJydcbiAgfSkpXG59XG4iXX0=